# 📋 TableON 학습 프로젝트: 시스템 아키텍처 및 플로우 가이드

## 1. 시스템 아키텍처 (System Architecture)

본 프로젝트는 **Flask 기반의 비동기 멀티쓰레딩 아키텍처**를 채택하고 있습니다. 하나의 프로세스 내에서 3개의 핵심 쓰레드가 독립적으로 작동하며 유기적으로 데이터를 주고받습니다.

### 🏗️ 3대 핵심 컴포넌트 (Threads)
1.  **Main Thread (Flask Server)**:
    *   외부(Node-RED, 브라우저, 키오스크)로부터의 HTTP 요청을 수신.
    *   주문을 `order_queue`에 삽입하거나 시스템 상태를 응답.
2.  **Robot Worker Thread**:
    *   `order_queue`를 감시하다가 주문이 들어오면 하나씩 꺼내어 제조 시퀀스(`run_robot_sequence`) 실행.
    *   로봇(IndyDCP3) 및 IO 장치(Modbus RTU)와 직접 통신하여 하드웨어 제어.
3.  **Monitor Worker Thread**:
    *   로봇의 상태를 실시간으로 감시.
    *   에러 발생(충돌, 비상정지 등) 시 즉시 프로그램을 중단시키고 큐를 비워 안전 확보.

---

## 2. 데이터 및 상태 관리 (Data & State)

| 구분 | 변수명 | 역할 |
| :--- | :--- | :--- |
| **작업 큐** | `order_queue` | 들어온 주문을 FIFO(First-In-First-Out) 방식으로 보관. |
| **픽업 상태** | `pickup_slots` | 4개의 픽업대 사용 여부(`True`/`False`)를 메모리에 저장. |
| **로봇 상태** | `robot.is_running` | 자동 운전 모드의 활성화 여부 제어. |
| **레지스터** | `101(CUP)`, `102(PICKUP)` | 로봇 프로그램과 통신하기 위한 공유 메모리 주소. |

---

## 3. 핵심 비즈니스 플로우 (Main Flow)

### ☕ 주문 및 제조 프로세스
1.  **주문 수신**: `GET /order/<menu_code>` 호출 → 레시피 로드 → `order_queue` 삽입.
2.  **작업 추출**: `robot_worker`가 큐에서 주문을 꺼내 `run_robot_sequence` 시작.
3.  **컵 배출**: 로봇 이동 → `CUP_IDX(101)`에 타입 기록 → 컵 배출 IO 트리거 → 센서 확인.
4.  **음료 제조**: 물/얼음/커피 구간별로 로봇 이동 및 IO(Pulse) 제어.
5.  **픽업 탐색 (핵심)**:
    *   `while` 루프 진입: `pickup_slots` 중 `False`인 가장 빠른 번호 탐색.
    *   자리가 없으면 대기(`time.sleep`), 자리가 생기면 `target_slot` 할당.
6.  **서빙 완료**: `PICKUP_IDX(102)`에 위치 기록 → 로봇 이동 → 슬롯 상태 `True` 변경.

### 🔄 픽업 해제 프로세스
1.  **수령 이벤트**: 사용자가 음료 수령 후 `GET /pickup/complete/<idx>` 호출.
2.  **상태 업데이트**: `pickup_slots[idx]`를 `False`로 변경.
3.  **즉시 반영**: 대기 중이던 `robot_worker`가 다음 루프에서 빈 자리를 감지하고 즉시 서빙 재개.

---

## 4. 현재 구조의 특징 및 장점

1.  **비동기 처리**: 주문을 받는 것과 로봇이 움직이는 것이 분리되어 있어, 제조 중에도 다음 주문을 계속 받을 수 있습니다.
2.  **안전 우선**: 모니터 쓰레드가 별도로 돌아가고 있어, 메인 로직이 꼬이더라도 로봇의 물리적 에러를 감지하여 즉시 정지시킵니다.
3.  **유연한 픽업**: 하드웨어 센서 없이도 소프트웨어적으로 완벽한 픽업대 관리 로직을 구현했습니다.
4.  **확장성**: 모든 제어가 API 기반이므로 노드레드, 웹, 앱 등 어떤 인터페이스와도 쉽게 연동됩니다.
